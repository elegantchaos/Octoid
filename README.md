<!-- Header Generated by ActionBuilderTool 2.1.2 (96) -->
<!-- See https://github.com/elegantchaos/ActionBuilderCore for more details. -->

[![Test results][tests shield]][actions] [![Latest release][release shield]][releases] [![swift 6.2 shield]][swift] ![Platforms: iOS, macOS, tvOS, watchOS][platforms shield]

[release shield]: https://img.shields.io/github/v/release/elegantchaos/Octoid
[platforms shield]: https://img.shields.io/badge/platforms-iOS_macOS_tvOS_watchOS-lightgrey.svg?style=flat "iOS, macOS, tvOS, watchOS"
[tests shield]: https://github.com/elegantchaos/Octoid/workflows/Tests/badge.svg
[swift 6.2 shield]: https://img.shields.io/badge/swift-6.2-F05138.svg "Swift 6.2"

[swift]: https://swift.org
[releases]: https://github.com/elegantchaos/Octoid/releases
[actions]: https://github.com/elegantchaos/Octoid/actions

<!-- End of ActionBuilderTool Header -->

# Octoid

Octoid is a focused Swift package that provides the GitHub API models and polling helpers used by ActionStatus.

## What It Includes

- GitHub payload models used by ActionStatus:
  - `Events` / `Event`
  - `Workflows` / `Workflow`
  - `WorkflowRuns` / `WorkflowRun`
  - Supporting types (`Actor`, `Author`, `Commit`, etc.)
- Resource resolvers for key endpoints:
  - `EventsResource`
  - `WorkflowsResource`
  - `WorkflowResource`
- Polling helpers built on `JSONSession` 2.x:
  - `Session` (Octoid wrapper around `JSONSession.Session`)
  - `MessageProcessor`
  - `UnchangedProcessor`
  - `MessageReceiver`

## Requirements

- Swift tools: 6.2
- Platforms:
  - macOS 26+
  - Mac Catalyst 26+
  - iOS 26+
  - tvOS 26+
  - watchOS 11+

## Installation

Add Octoid to your package dependencies:

```swift
dependencies: [
    .package(url: "https://github.com/elegantchaos/Octoid.git", from: "1.0.0")
]
```

Then add `Octoid` to the target dependencies that need it.

## Quick Start

Create an Octoid session and poll a resource with a typed context and processor group.

```swift
import Foundation
import JSONSession
import Octoid

actor EventsContext: MessageReceiver {
    private(set) var events: Events?
    private(set) var message: Message?

    func capture(events: Events) {
        self.events = events
    }

    func received(
        _ message: Message,
        response: HTTPURLResponse,
        for _: Request<EventsContext>
    ) async -> RepeatStatus {
        self.message = message
        return .cancel
    }
}

struct EventsCaptureProcessor: Processor {
    typealias Context = EventsContext
    typealias Payload = Events

    let name = "events"
    let codes = [200]

    func process(
        _ payload: Events,
        response: HTTPURLResponse,
        for _: Request<EventsContext>,
        in context: EventsContext
    ) async throws -> RepeatStatus {
        await context.capture(events: payload)
        return .cancel
    }
}

let session = Session(token: githubToken)
let context = EventsContext()
let resource = EventsResource(name: "Octoid", owner: "elegantchaos")

session.poll(
    target: resource,
    context: context,
    processors: AnyProcessorGroup(
        name: "events",
        processors: [
            EventsCaptureProcessor().eraseToAnyProcessor(),
            MessageProcessor<EventsContext>().eraseToAnyProcessor(),
        ]
    ),
    for: .now()
)
```

## Workflow Runs

Use `WorkflowResource` in one of three modes:

1. By workflow name: `WorkflowResource(name:owner:workflow:)`
2. By workflow ID: `WorkflowResource(name:owner:workflowID:)`
3. All workflows: `WorkflowResource.allWorkflows(name:owner:)`

If workflow names are not stable, fetch `WorkflowsResource` first and use `workflows.preferredWorkflow?.id`.

## Testing

See [`TESTING.md`](TESTING.md) for local and integration test setup.
